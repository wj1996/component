消息发布时的权衡
    性能+可靠性
    快低
        1.无保障
        2.失败通知
            发送消息时设置mandatory标志，只会告诉失败，不会告诉是否成功，被成功投递的是不会有通知的
            可靠性仅比无保障高一点，可靠性并不是特别高的，可能出现的情况，消息发送失败，没有被成功投递，失败通知的时候
            网络存在问题，此时rabbitmq会认为消息成功了
        3.发布者确认
            rabbit团队为我们拿出了更好的方案，即采用发送方确认模式，该模式比事务更轻量，性能影响几乎可以忽略不计。

            rabbitmq投送到消费者以后

            消息不可路由时：
                结合失败通知
            消息可路由时：
                由交换器将这个消息发送到队列，发送消息成功，会给生产者返回ACK的信息。发生内部错误无法投递队列时返回Nack

            三种方式：
                1. 发送一条消息等待确认后才能发送下一条
                2. 批量确认，发送消息过程中，有任意一条出错，生产者会抛错

        4.备用交换器
            交换器无法路由时，会将这个消息会被路由到备用交换器
            同时启用备用交换器和失败通知，此时，设置失败通知将没有实际意义
            避免消息丢失（无路由时）
        5.高可用队列
            使用在集群环境下面
        6.事务（实际生产用的很少）
            严重的性能问题
        7.事务+高可用队列（实际生产用的很少）
        8.消息的持久化
            最慢，最可靠
    慢，高


    消息的获得模式（默认一次取一条）：
        拉取
        推送
            监听模式属于推送
    消息的应答
        自动确认
        手动确认


    Qos预取模式(建议，可靠性和性能相对比较高)


    性能


    消息的拒绝
        Reject
            一条一条的拒绝
        Nack
            批量的拒绝  非AMQP标准的内容，rabbit的扩充

    死信交换器DLX
        1. 消息投递被消费者拒绝，但是不允许重新投递
        2. 消息过期



    比如：这个
        channel.queueDeclare(queueName,false,false,false,argsMap);
    队列控制
        临时队列
            自动删除队列
                设置第四个参数为true（autoDelete），当所有的这个队列的消费者与rabbitmq断开连接后，这个队列的消息就会被自动删除
            单消费者队列
                第三个参数（exclusive），一个队列运行多个消费者，设置为true，一个消息队列智能被一个消费者独享
            自动过期队列
                x-expires
                如果队列在一段时间没有被使用，会被rabbitmq删除
                    1. rabbitmq 一段时间没有没有消费者连接在队列上
                    2. rabbitmq 一段时间没有消费者去拿消息
                    3. 不断有生产者往消费者发送消息，但是没有消费者连接，或者主动去获取，这种也会自动过期，是否自动过期的决定因素是是否有消费者连接
                    并且消费
            x开头的参数都是通过定义map传递
        永久队列
            队列的持久性
                第二个参数（durable）
                设置为true
        队列级别消息过期
            x-message-ttl   时间单位毫秒，设置消息的存活时间（从进入队列开始计算）



    x-max-priority   最大优先值为255的队列优先排序功能
消息的属性
    message-id  消息的唯一性标识，由应用进行设置
    timestamp   消息的创建时刻，整形，精确到秒
    expiration  消息的过期时刻， 字符串，但是呈现格式为整型，精确到秒
        同时设置，以短的为准

    例子：
        如果发送了一条消息，设置的过期时间是21:33:35 但是创建时间是21:33:34  这样的消息发送到rabbitmq，不会路由到任何队列，会直接丢弃
    delivery-mode  消息的持久化类型，1为非持久化，2为持久化，性能影响巨大
        消息的持久化不是消息的持久化就可以了，rabbitmq中，消息的持久化离不开交换器和队列的持久化，在缺省情况下，交换器和队列在重启后会消失的。

    type    消息类型名称，完全由应用决定如何使用该字段
    reply-to  构建回复消息的私有响应队列
    priority    指定队列中消息的优先级

与spring集成
    spring中控制消息属性通过MessageProperties对象


spring集成实战，订单系统与库存系统
   1. 订单系统发送消息到MQ，必须保证消息发送到MQ，使用发送者确认
   2. 消息发送到消息队列，万一MQ挂了，需要使用消息的持久化   ------>注意：消息的持久化 包括交换器，队列，消息三者的持久化才行
   3. 消息队列将消息发送给了库存系统，库存系统刚好存在问题，手动确认


Rabbitmq来实现分布式事务

    原理：最终一致性

    1.确保生产者的消息一定能投递到MQ服务器端
    2.MQ消费者能


    生产者投递消息到MQ服务器成功后
        场景1：如果消费者消息失败了，生产者不需要回滚事务，消费者采用手动ACK，进行补偿重试机制。
        （注意幂等性）

    问题：如何确保消息一定能发送到服务器端。
            发布者确认

          如果生产者发送消息到MQ服务器失败呢？？？
            使用生产者重试机制

    场景3：
        投递到MQ成功了，消费者消费成功了，生产者的事务回滚了。



    比如：外卖系统里面的下单系统和派单系统

    订单系统    》》》》   下单系统

    传统形式解决派单问题：通过Http协议形式调用下单系统.
        请求很多，可以做限流，做熔断，做服务降级
        但是这样做是不好的，做限流，做熔断会造成某些数据丢失。

    使用MQ
        订单服务（P）》》》 派单交换器（X），使用两个队列
            补单队列    补单消费者

            派单队列    派单消费者

